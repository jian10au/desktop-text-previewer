const { app, BrowserWindow, dialog} = require('electron')
const {autoUpdater} = require('electron-updater')
const isDev = require('electron-is-dev')
const fs = require('fs')


// Setup the autoUpdater

autoUpdater.logger = require('electron-log')
autoUpdater.logger.transports.file.level = 'info'

// Setup the event listeners for autoUpdater;
autoUpdater.on('checking-for-update', () => {
    console.log('Checking for updates...')
})

autoUpdater.on('update-available', (info) => {
    console.log('Update avaiable')
    console.log('Version', info.version)
    console.log('Release data', info.releaseDate)
})

autoUpdater.on('update-not-available', () => {
    console.log('Update not available');
})

autoUpdater.on('download-progress', (progress) => {
    console.log(`Progress ${Math.floor(progress.percent)}`)
})

autoUpdater.on('update-downloaded', (info) => {
    console.log('Update downloaded')
    autoUpdater.quitAndInstall()
})

autoUpdater.on('error', (error) => {
    console.log(error)
})

// electron can actuall interact with a lot of desktop feature even include the support for the the touch bar feature your can find in the new macbook.

//directly under the electron it is the modules that you can use to play with the electron app.

let mainWindow = null;
// the reason why you want to have a new variable in here is that you want to make sure nothing will
// be garbage collected from js process; what is garbage colletion at all

// notice below actually is the show 
app.on('ready',() => {
    console.log('The App is Ready')
    if(!isDev) {
        autoUpdater.checkForUpdates();
    }
    mainWindow = new BrowserWindow(
        {show:false,
        webPreferences:{
            nodeIntegration:true
        }});

    // the require syntax will only work if you set the BrowserWindow property as true;

    mainWindow.loadFile(`${__dirname}/index.html`)
     // it seems to me the above code is the same as doing mainWindow.loadFile("./index.html")
    //  so is that the diference lies in the fact relative reference vs absolute reference?
   

    // notice, it gets used in here meaning that this is really useful;
    // getFileFromUser();


    // __dirname is the same as the bash command pwd
    // what is the difference between on and once?
    // can I just do main.Window.loadFile("./index.html")
    mainWindow.once('ready-to-show', () => {
        mainWindow.show();
    })

})

const getFileFromUser = () => {
    const files = dialog.showOpenDialogSync(
        {
            properties:['openFile'],
            // you can add filter in here;
            buttonLabel: 'unveil',
            filters: [
                {name: 'Markdown Files', extensions:['md', 'markdown', 'mdown']},
                {name: 'Text Files', extensions: ['txt','text','md']}
            ]
        }
    )

    console.log(files)
    if(!files) {
        return 
        // early return in here effectively does nothing at all.
    }

    const file = files[0];
    // although this thing is called file, it is actually a file path, the array is generated by
    // the diag, the dialog basically allow a user to select multiple file within the system;
    // if I don't put the toString(); you will get an buffer only.
    
    openFile(file);

    console.log(content)
    // returns undefined or null (when a user hit cancel), 
    // or a array of file number (when a user choose multiple file) path string
    // depending the user selection, array means a user can select multiple file
    // notice, this is to open the syste native dialog
}

// open the window instead of just console.log(what is open and their string, send things
// back to the rendered process)
const openFile = (file) => {
    const content = fs.readFileSync(file).toString();
    mainWindow.webContents.send('file-opened', file, content)
    // this process is exactly look res.send('something in here')
}


exports.getFileFromUser = getFileFromUser
